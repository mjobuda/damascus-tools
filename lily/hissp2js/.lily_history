
# 2021-09-09 18:31:59.125881
+4

# 2021-09-09 18:31:59.608840
+5

# 2021-09-09 18:32:00.145386
+6

# 2021-09-09 18:32:00.579969
+7

# 2021-09-09 18:32:06.542861
+4

# 2021-09-09 18:32:09.476151
+7

# 2021-09-09 19:06:13.587148
+fsdf

# 2021-09-09 19:06:34.383736
+(callable)

# 2021-09-09 19:07:41.884212
+defmacro

# 2021-09-09 19:16:30.831393
+7

# 2021-09-09 19:17:35.512110
+ter

# 2021-09-09 19:17:40.287654
+7

# 2021-09-09 19:18:00.439878
+fgdgd

# 2021-09-09 19:18:32.067006
+'fgdgd

# 2021-09-09 19:18:52.714884
+(fdf vert)

# 2021-09-09 19:19:48.479187
+5

# 2021-09-09 19:19:49.326314
+6

# 2021-09-09 19:19:51.278613
+gdtr

# 2021-09-09 19:20:59.823722
+76

# 2021-09-09 19:21:08.927874
+(abs 6)

# 2021-09-09 19:27:19.875060
+5

# 2021-09-09 19:29:01.432607
+6

# 2021-09-09 19:29:02.397545
+8

# 2021-09-09 19:29:11.480235
+10

# 2021-09-09 19:37:11.921235
+(print "fdfdgfgd")

# 2021-09-09 19:37:27.379266
+'(print "fdfdgfgd")

# 2021-09-09 19:40:00.598453
+'(print "fdfdgfgd")]

# 2021-09-09 19:45:41.281575
+(define + operator..add)

# 2021-09-09 19:45:48.253861
+(+ 5 6)

# 2021-09-09 19:46:04.813968
+5

# 2021-09-09 19:46:06.147869
+7

# 2021-09-09 19:46:09.173585
+(+ 5 6)

# 2021-09-09 20:30:23.881113
+5

# 2021-09-09 20:30:25.714998
+(+ 5 6)

# 2021-09-09 20:51:29.522273
+
+ 
+(abs 6)
+(+ 5 6)
+
+

# 2021-09-09 20:51:45.470862
+
+(abs 6)
+(+ 5 6)

# 2021-09-09 20:53:24.209500
+7

# 2021-09-09 20:53:32.875317
+
+(abs 6)
+
+(+ 5 6)

# 2021-09-09 20:53:47.078742
+(define + operator..add)

# 2021-09-09 20:54:52.048353
+defmacro

# 2021-09-09 20:58:11.426549
+(define + operator..add)

# 2021-09-09 21:02:12.826432
+(operator.)

# 2021-09-09 21:02:22.252995
+(operator)

# 2021-09-09 21:02:33.060089
+gfgf

# 2021-09-09 21:02:39.934547
+(gfdgf)

# 2021-09-09 21:05:41.095461
+(operator)

# 2021-09-09 21:05:44.024568
+(define + operator..add)

# 2021-09-09 21:07:03.885771
+(operator)

# 2021-09-09 21:09:13.601243
+
+(abs 6)
+
+

# 2021-09-09 21:09:30.072922
+(abs 6)

# 2021-09-09 21:09:46.133842
+6

# 2021-09-09 21:09:47.305651
+7

# 2021-09-09 21:10:40.568930
+(abs 6)

# 2021-09-09 21:11:05.028739
+
+(abs 6)
+
+

# 2021-09-09 21:11:09.585739
+(define + operator..add)

# 2021-09-09 21:13:12.080904
+(globals)

# 2021-09-09 21:18:02.588826
+(prelude)

# 2021-09-09 21:19:00.391382
+(operator..setitem (globals) '_macro_ (types..ModuleType '_macro_))

# 2021-09-09 21:19:27.809748
+;; Bootstrap enough macros to define the 'defmacro' macro. Dawg.
+
+;; Simplified bootstrap version assumes ideal conditions to avoid branching.
+(setattr _macro_
+         'defmacro
+         (lambda (name parameters docstring : :* body)
+           `((lambda (: $#G (lambda ,parameters ,@body))
+               (setattr $#G ','__doc__ ,docstring)
+               (setattr $#G ','__qualname__ (.join "." '(,'_macro_ ,name)))
+               (setattr _macro_ ',name $#G)))))
+
+(defmacro if-else (test then otherwise)
+  "``if-else`` Basic ternary branching construct.
+
+  Like Python's conditional expressions, the 'else' clause is required.
+  "
+  `((lambda (,'test : :* ,'then-else)
+      ((operator..getitem ,'then-else (operator..not_ ,'test))))
+    ,test
+    (lambda : ,then)
+    (lambda : ,otherwise)))
+
+(defmacro progn (: :* body)
+  "Evaluates each body expression in sequence (for side effects),
+  resulting in the value of the last (or ``()`` if empty).
+  "
+  ;; TODO: consider flattening nested progns
+  `((lambda :
+      ,@body)))
+
+(defmacro when (condition : :* body)
+  "When the condition is true,
+  evaluates each expression in sequence for side effects,
+  resulting in the value of the last.
+  Otherwise, skips them and returns ``()``.
+  "
+  `(if-else ,condition (progn ,@body) ()))
+
+(defmacro unless (condition : :* body)
+  "Unless the condition is true,
+  evaluates each expression in sequence for side effects,
+  resulting in the value of the last.
+  Otherwise, skips them and returns ``()``.
+  "
+  `(if-else ,condition () (progn ,@body)))
+
+(defmacro let (pairs : :* body)
+  "Creates local variables. Pairs are implied. Locals are not in scope until the body."
+  `((lambda (: ,@pairs)
+      ,@body)))
+
+;;;; Post-bootstrap
+
+;;; definition
+
+;; Define the real defmacro using the bootstrap macros.
+(defmacro defmacro (name parameters : docstring () :* body)
+  "Creates a new macro for the current module.
+
+  If there's no ``_macro_``, creates one (using `types.ModuleType`).
+  If there's a docstring, stores it as the new lambda's ``__doc__``.
+  Adds the ``_macro_`` prefix to the lambda's ``__qualname__``.
+  Saves the lambda in ``_macro_`` using the given attribute name.
+  "
+  (let ($fn `$#fn)
+    (let (fn `(lambda ,parameters ,docstring ,@body)
+          ns (unless (operator..contains (.get hissp.compiler..NS) '_macro_)
+               `((operator..setitem (globals) ','_macro_ (types..ModuleType ','_macro_))))
+          dc (when (hissp.reader..is_string docstring)
+               `((setattr ,$fn ','__doc__ ,docstring)))
+          qn `(setattr ,$fn ','__qualname__ (.join "." '(,'_macro_ ,name))))
+      `(let (,$fn ,fn)
+         ,@ns
+         ,@dc
+         ,qn
+         (setattr (operator..getitem (builtins..globals)
+                                     ','_macro_)
+                  ',name
+                  ,$fn)))))
+
+(defmacro define (name value)
+  "Assigns a global the value in the current module."
+  `(operator..setitem (builtins..globals)
+                      ',name
+                      ,value))
+
+(defmacro deftype (name bases : :* body)
+  "Defines a type (class) in the current module.
+
+  Key-value pairs are implied in the body.
+  "
+  `(define ,name
+       (type ',name (,hissp.reader..ENTUPLE ,@bases)
+             (dict : ,@body))))
+
+;; see also from bootstrap: let
+
+(define _TAO "
+Nothingness above abstraction
+  but implementation is / the best name.
+Terseness may make one too many / get used to them
+  else overflow your brain.
+No substitute for understanding
+Code;     the liability
+as asset; the   ability.
+The biggest chunks / are hard to swallow
+  as simple as possible / no more.
+Source was made / for the human
+  object / the machine.
+Are you lazy enough to bear / the sincerest form / of other ways of being?
+*having* decent standards / is more important / than exactly what they are
+Perfection / is expensive
+  magic / highly priced
+  pay for when / it's Worth It
+  a quarter is advised
+Readability / is mainly / laid out on the page.
+Golfing / makes good practice / best practice it betrays.
+Castles built / in the air / whither they do belong?
+  Elegance / then exception
+  Form / before detail
+  whence under them,
+Foundations appear.
+Make the right way obvious,
+meditate on this.
+  --Za Zen of Hissp
+")
+
+(defmacro import (: :* args)
+  `(print _TAO))
+
+;;; configuration
+
+(defmacro attach (target : :* args)
+  "Attaches the named variables to the target as attributes.
+
+  Positional arguments must be unqualified identifiers,
+  and use that as the attribute name.
+  Names after the ``:`` are identifier-value pairs.
+  Returns the target.
+  "
+  (let (iargs (iter args)
+        $target `$#target)
+    (let (args (itertools..takewhile (lambda (a)
+                                       (operator..ne a ':))
+                                     iargs))
+      `(let (,$target ,target)
+         ,@(map (lambda (arg)
+                  `(setattr ,$target ',arg ,arg))
+                args)
+         ,@(map (lambda (kw)
+                  `(setattr ,$target ',kw ,(next iargs)))
+                iargs)
+         ,$target))))
+
+(defmacro cascade (self : :* invocations)
+  "Call multiple 'methods' on one 'self'.
+
+  Evaluates the given ``self``, then injects it as the first argument to
+  a sequence of invocations. Returns the result of the last one.
+  "
+  (let ($self `$#self)
+    `((lambda (: ,$self ,self)
+        ,@(map (lambda (invocation)
+                 `(,(operator..getitem invocation 0)
+                   ,$self
+                   ,@(operator..getitem invocation (slice 1 None))))
+               invocations)))))
+
+;;; threading
+
+(defmacro -> (expr : :* forms)
+  "``->`` 'Thread-first'.
+
+  Converts a pipeline to function calls by recursively threading
+  expressions as the first argument of the next form.
+  E.g. ``(-> x (A b) (C d e))`` is ``(C (A x b) d e)``
+  Makes chained method calls easier to read.
+  "
+  (if-else forms
+    `(-> (,(operator..getitem (operator..getitem forms 0) 0)
+          ,expr
+          ,@(operator..getitem (operator..getitem forms 0)
+                               (slice 1 None)))
+         ,@(operator..getitem forms (slice 1 None)))
+    expr))
+
+(defmacro ->> (expr : :* forms)
+  "``->>`` 'Thread-last'.
+
+  Converts a pipeline to function calls by recursively threading
+  expressions as the last argument of the next form.
+  E.g. ``(->> x (A b) (C d e))`` is ``(C d e (A b x))``.
+  Can replace partial application in some cases.
+  Also works inside a ``->`` pipeline.
+  E.g. ``(-> x (A a) (->> B b) (C c))`` is ``(C (B b (A x a)) c)``.
+  "
+  (if-else forms
+    `(->> (,@(operator..getitem forms 0) ,expr)
+          ,@(operator..getitem forms (slice 1 None)))
+    expr))
+
+;; TODO: implement other arrange macros?
+
+;;; control flow
+
+(defmacro cond (: :* pairs)
+  #"Multiple condition branching.
+
+  Pairs are implied. Default is ``()``. Use ``:else`` to change it.
+  For example::
+
+   (cond)  ; ()
+   ;; Assume some number 'x
+   (cond (operator..gt x 0) (print \"positive\")
+         (operator..lt x 0) (print \"negative\")
+         (operator..eq x 0) (print \"zero\")
+         :else (print \"not a number\"))
+  "
+  (when pairs
+    `(if-else ,(operator..getitem pairs 0)
+              ,(operator..getitem pairs 1)
+              ;; Here's the recursive part.
+              (cond ,@(operator..getitem pairs (slice 2 None))))))
+
+(defmacro any-for (variable iterable : :* body)
+  "``any-for``
+  Bind the variable and evaluate the body for each item from the
+  iterable until any result is true (and return ``True``),
+  or until the iterable is exhausted (and return ``False``).
+  "
+  `(any (map (lambda (,variable)
+               ,@body)
+             ,iterable)))
+
+;; I would have named this 'and, but that's a reserved word.
+(defmacro && (: :* exprs)
+  "``&&`` 'and'. Shortcutting logical AND.
+  Returns the first false value, otherwise the last value.
+  There is an implicit initial value of ``True``.
+  "
+  (cond (operator..not_ exprs) True
+        (operator..eq (len exprs) 1) (operator..getitem exprs 0)
+        :else `(let ($#G ,(operator..getitem exprs 0))
+                 (if-else $#G
+                          (&& ,@(operator..getitem exprs (slice 1 None)))
+                          $#G))))
+
+(defmacro || (: first () :* rest)
+  "``||`` 'or'. Shortcutting logical OR.
+  Returns the first true value, otherwise the last value.
+  There is an implicit initial value of ``()``.
+  "
+  (if-else rest
+           `(let ($#first ,first)
+              (if-else $#first
+                       $#first
+                       (|| ,@rest)))
+           first))
+
+;; TODO: implement case macro?
+
+;; see also from bootstrap: if-else, when, unless
+
+;;; side effect
+
+(defmacro prog1 (expr1 : :* body)
+  "Evaluates each expression in sequence (for side effects),
+  resulting in the value of the first."
+  `(let ($#value1 ,expr1)
+     ,@body
+     $#value1))
+
+;; see also from bootstrap: progn
+
+;; Note that any of the basic macros with a lambda "body" argument
+;; also sequence expressions for side effects.
+
+;;; reader
+
+(defmacro b\# (raw)
+  "``b#`` bytes literal reader macro"
+  (-> raw
+      (.replace "'" "\'")
+      (.replace #"\n" "\n")
+      (->> (.format "b'{}'"))
+      (ast..literal_eval)))
+
+;;; import
+
+(defmacro prelude ()
+  "Grants unqualified access to the basics.
+
+  Star imports from `operator` and `itertools`.
+  And adds the basic macros, but only if available,
+  so its expansion does not require Hissp to be installed.
+  (This replaces ``_macro_`` if you already had one.)
+  "
+  `(exec #"\
+from operator import *
+from itertools import *
+try:
+    from hissp.basic import _macro_
+    _macro_ = __import__('types').SimpleNamespace(**vars(_macro_))
+except ModuleNotFoundError:
+    pass"))
+
+(defmacro alias (alias module)
+  "Defines a reader macro abbreviation of a symbol prefix
+  (such as a qualifier). For example,
+
+  .. code-block:: Lissp
+
+     (hissp.basic.._macro_.alias b/ hissp.basic.._macro_.)
+     ;; Now the same as (hissp.basic.._macro_.define foo 2).
+     (b/#define foo 2)
+  "
+  `(defmacro ,(.format "{}{}" alias '#)
+             ($#G)
+     ',(.format "Aliases {} as {}#" module alias)
+     (.format "{}{}" ',module $#G)))
+
+

# 2021-09-09 21:19:42.369679
+;; Bootstrap enough macros to define the 'defmacro' macro. Dawg.
+
+;; Simplified bootstrap version assumes ideal conditions to avoid branching.
+(setattr _macro_
+         'defmacro
+         (lambda (name parameters docstring : :* body)
+           `((lambda (: $#G (lambda ,parameters ,@body))
+               (setattr $#G ','__doc__ ,docstring)
+               (setattr $#G ','__qualname__ (.join "." '(,'_macro_ ,name)))
+               (setattr _macro_ ',name $#G)))))
+
+(defmacro if-else (test then otherwise)
+  "``if-else`` Basic ternary branching construct.
+
+  Like Python's conditional expressions, the 'else' clause is required.
+  "
+  `((lambda (,'test : :* ,'then-else)
+      ((operator..getitem ,'then-else (operator..not_ ,'test))))
+    ,test
+    (lambda : ,then)
+    (lambda : ,otherwise)))
+
+(defmacro progn (: :* body)
+  "Evaluates each body expression in sequence (for side effects),
+  resulting in the value of the last (or ``()`` if empty).
+  "
+  ;; TODO: consider flattening nested progns
+  `((lambda :
+      ,@body)))
+
+(defmacro when (condition : :* body)
+  "When the condition is true,
+  evaluates each expression in sequence for side effects,
+  resulting in the value of the last.
+  Otherwise, skips them and returns ``()``.
+  "
+  `(if-else ,condition (progn ,@body) ()))
+
+(defmacro unless (condition : :* body)
+  "Unless the condition is true,
+  evaluates each expression in sequence for side effects,
+  resulting in the value of the last.
+  Otherwise, skips them and returns ``()``.
+  "
+  `(if-else ,condition () (progn ,@body)))
+
+(defmacro let (pairs : :* body)
+  "Creates local variables. Pairs are implied. Locals are not in scope until the body."
+  `((lambda (: ,@pairs)
+      ,@body)))
+
+;;;; Post-bootstrap
+
+;;; definition
+
+;; Define the real defmacro using the bootstrap macros.
+(defmacro defmacro (name parameters : docstring () :* body)
+  "Creates a new macro for the current module.
+
+  If there's no ``_macro_``, creates one (using `types.ModuleType`).
+  If there's a docstring, stores it as the new lambda's ``__doc__``.
+  Adds the ``_macro_`` prefix to the lambda's ``__qualname__``.
+  Saves the lambda in ``_macro_`` using the given attribute name.
+  "
+  (let ($fn `$#fn)
+    (let (fn `(lambda ,parameters ,docstring ,@body)
+          ns (unless (operator..contains (.get hissp.compiler..NS) '_macro_)
+               `((operator..setitem (globals) ','_macro_ (types..ModuleType ','_macro_))))
+          dc (when (hissp.reader..is_string docstring)
+               `((setattr ,$fn ','__doc__ ,docstring)))
+          qn `(setattr ,$fn ','__qualname__ (.join "." '(,'_macro_ ,name))))
+      `(let (,$fn ,fn)
+         ,@ns
+         ,@dc
+         ,qn
+         (setattr (operator..getitem (builtins..globals)
+                                     ','_macro_)
+                  ',name
+                  ,$fn)))))
+
+(defmacro define (name value)
+  "Assigns a global the value in the current module."
+  `(operator..setitem (builtins..globals)
+                      ',name
+                      ,value))
+
+(defmacro deftype (name bases : :* body)
+  "Defines a type (class) in the current module.
+
+  Key-value pairs are implied in the body.
+  "
+  `(define ,name
+       (type ',name (,hissp.reader..ENTUPLE ,@bases)
+             (dict : ,@body))))
+
+;; see also from bootstrap: let
+
+(define _TAO "
+Nothingness above abstraction
+  but implementation is / the best name.
+Terseness may make one too many / get used to them
+  else overflow your brain.
+No substitute for understanding
+Code;     the liability
+as asset; the   ability.
+The biggest chunks / are hard to swallow
+  as simple as possible / no more.
+Source was made / for the human
+  object / the machine.
+Are you lazy enough to bear / the sincerest form / of other ways of being?
+*having* decent standards / is more important / than exactly what they are
+Perfection / is expensive
+  magic / highly priced
+  pay for when / it's Worth It
+  a quarter is advised
+Readability / is mainly / laid out on the page.
+Golfing / makes good practice / best practice it betrays.
+Castles built / in the air / whither they do belong?
+  Elegance / then exception
+  Form / before detail
+  whence under them,
+Foundations appear.
+Make the right way obvious,
+meditate on this.
+  --Za Zen of Hissp
+")
+
+(defmacro import (: :* args)
+  `(print _TAO))
+
+;;; configuration
+
+(defmacro attach (target : :* args)
+  "Attaches the named variables to the target as attributes.
+
+  Positional arguments must be unqualified identifiers,
+  and use that as the attribute name.
+  Names after the ``:`` are identifier-value pairs.
+  Returns the target.
+  "
+  (let (iargs (iter args)
+        $target `$#target)
+    (let (args (itertools..takewhile (lambda (a)
+                                       (operator..ne a ':))
+                                     iargs))
+      `(let (,$target ,target)
+         ,@(map (lambda (arg)
+                  `(setattr ,$target ',arg ,arg))
+                args)
+         ,@(map (lambda (kw)
+                  `(setattr ,$target ',kw ,(next iargs)))
+                iargs)
+         ,$target))))
+
+(defmacro cascade (self : :* invocations)
+  "Call multiple 'methods' on one 'self'.
+
+  Evaluates the given ``self``, then injects it as the first argument to
+  a sequence of invocations. Returns the result of the last one.
+  "
+  (let ($self `$#self)
+    `((lambda (: ,$self ,self)
+        ,@(map (lambda (invocation)
+                 `(,(operator..getitem invocation 0)
+                   ,$self
+                   ,@(operator..getitem invocation (slice 1 None))))
+               invocations)))))
+
+;;; threading
+
+(defmacro -> (expr : :* forms)
+  "``->`` 'Thread-first'.
+
+  Converts a pipeline to function calls by recursively threading
+  expressions as the first argument of the next form.
+  E.g. ``(-> x (A b) (C d e))`` is ``(C (A x b) d e)``
+  Makes chained method calls easier to read.
+  "
+  (if-else forms
+    `(-> (,(operator..getitem (operator..getitem forms 0) 0)
+          ,expr
+          ,@(operator..getitem (operator..getitem forms 0)
+                               (slice 1 None)))
+         ,@(operator..getitem forms (slice 1 None)))
+    expr))
+
+(defmacro ->> (expr : :* forms)
+  "``->>`` 'Thread-last'.
+
+  Converts a pipeline to function calls by recursively threading
+  expressions as the last argument of the next form.
+  E.g. ``(->> x (A b) (C d e))`` is ``(C d e (A b x))``.
+  Can replace partial application in some cases.
+  Also works inside a ``->`` pipeline.
+  E.g. ``(-> x (A a) (->> B b) (C c))`` is ``(C (B b (A x a)) c)``.
+  "
+  (if-else forms
+    `(->> (,@(operator..getitem forms 0) ,expr)
+          ,@(operator..getitem forms (slice 1 None)))
+    expr))
+
+;; TODO: implement other arrange macros?
+
+;;; control flow
+
+(defmacro cond (: :* pairs)
+  #"Multiple condition branching.
+
+  Pairs are implied. Default is ``()``. Use ``:else`` to change it.
+  For example::
+
+   (cond)  ; ()
+   ;; Assume some number 'x
+   (cond (operator..gt x 0) (print \"positive\")
+         (operator..lt x 0) (print \"negative\")
+         (operator..eq x 0) (print \"zero\")
+         :else (print \"not a number\"))
+  "
+  (when pairs
+    `(if-else ,(operator..getitem pairs 0)
+              ,(operator..getitem pairs 1)
+              ;; Here's the recursive part.
+              (cond ,@(operator..getitem pairs (slice 2 None))))))
+
+(defmacro any-for (variable iterable : :* body)
+  "``any-for``
+  Bind the variable and evaluate the body for each item from the
+  iterable until any result is true (and return ``True``),
+  or until the iterable is exhausted (and return ``False``).
+  "
+  `(any (map (lambda (,variable)
+               ,@body)
+             ,iterable)))
+
+;; I would have named this 'and, but that's a reserved word.
+(defmacro && (: :* exprs)
+  "``&&`` 'and'. Shortcutting logical AND.
+  Returns the first false value, otherwise the last value.
+  There is an implicit initial value of ``True``.
+  "
+  (cond (operator..not_ exprs) True
+        (operator..eq (len exprs) 1) (operator..getitem exprs 0)
+        :else `(let ($#G ,(operator..getitem exprs 0))
+                 (if-else $#G
+                          (&& ,@(operator..getitem exprs (slice 1 None)))
+                          $#G))))
+
+(defmacro || (: first () :* rest)
+  "``||`` 'or'. Shortcutting logical OR.
+  Returns the first true value, otherwise the last value.
+  There is an implicit initial value of ``()``.
+  "
+  (if-else rest
+           `(let ($#first ,first)
+              (if-else $#first
+                       $#first
+                       (|| ,@rest)))
+           first))
+
+;; TODO: implement case macro?
+
+;; see also from bootstrap: if-else, when, unless
+
+;;; side effect
+
+(defmacro prog1 (expr1 : :* body)
+  "Evaluates each expression in sequence (for side effects),
+  resulting in the value of the first."
+  `(let ($#value1 ,expr1)
+     ,@body
+     $#value1))
+
+;; see also from bootstrap: progn
+
+;; Note that any of the basic macros with a lambda "body" argument
+;; also sequence expressions for side effects.
+
+;;; reader
+
+(defmacro b\# (raw)
+  "``b#`` bytes literal reader macro"
+  (-> raw
+      (.replace "'" "\'")
+      (.replace #"\n" "\n")
+      (->> (.format "b'{}'"))
+      (ast..literal_eval)))
+
+;;; import
+
+(defmacro prelude ()
+  "Grants unqualified access to the basics.
+
+  Star imports from `operator` and `itertools`.
+  And adds the basic macros, but only if available,
+  so its expansion does not require Hissp to be installed.
+  (This replaces ``_macro_`` if you already had one.)
+  "
+  `(exec #"\
+from operator import *
+from itertools import *
+try:
+    from hissp.basic import _macro_
+    _macro_ = __import__('types').SimpleNamespace(**vars(_macro_))
+except ModuleNotFoundError:
+    pass"))
+
+(defmacro alias (alias module)
+  "Defines a reader macro abbreviation of a symbol prefix
+  (such as a qualifier). For example,
+
+  .. code-block:: Lissp
+
+     (hissp.basic.._macro_.alias b/ hissp.basic.._macro_.)
+     ;; Now the same as (hissp.basic.._macro_.define foo 2).
+     (b/#define foo 2)
+  "
+  `(defmacro ,(.format "{}{}" alias '#)
+             ($#G)
+     ',(.format "Aliases {} as {}#" module alias)
+     (.format "{}{}" ',module $#G)))
+
+
+
+

# 2021-09-09 21:20:54.674921
+(setattr _macro_
+         'defmacro
+         (lambda (name parameters docstring : :* body)
+           `((lambda (: $#G (lambda ,parameters ,@body))
+               (setattr $#G ','__doc__ ,docstring)
+               (setattr $#G ','__qualname__ (.join "." '(,'_macro_ ,name)))
+               (setattr _macro_ ',name $#G)))))
+
+

# 2021-09-09 21:22:19.525988
+.#"import operator as op"

# 2021-09-09 21:22:31.859939
+(op.add 1 1)

# 2021-09-09 21:25:23.719387
+(operator..truediv 1 0)

# 2021-09-09 21:56:52.094275
+(hissp.)

# 2021-09-09 21:57:01.519380
+hissp.

# 2021-09-09 21:57:12.148439
+hissp..basic

# 2021-09-09 21:57:21.371811
+hissp.__dir__

# 2021-09-09 21:57:38.742132
+(dir hissp)

# 2021-09-09 21:57:50.968791
+os

# 2021-09-09 21:57:58.220341
+os.

# 2021-09-09 21:58:00.918805
+os

# 2021-09-09 22:04:06.171223
+(dir hissp)

# 2021-09-09 22:04:15.198023
+defmacro

# 2021-09-09 22:04:26.195609
+(defmacro alias (alias module))

# 2021-09-09 22:05:32.284404
+defmacro

# 2021-09-09 22:05:34.035648
+(defmacro alias (alias module))

# 2021-09-09 22:05:46.181655
+(dir hissp)

# 2021-09-09 22:07:15.742353
+(defmacro alias (alias module))

# 2021-09-09 22:08:16.244840
+(dir hissp)

# 2021-09-09 22:08:24.075078
+(defmacro alias (alias module))

# 2021-09-09 22:09:11.446712
+(operator..truediv 1 0)

# 2021-09-09 22:09:17.219975
+(operator..truediv 1 2)

# 2021-09-09 22:11:03.078874
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:11:15.280938
+(defmacro alias (alias module))

# 2021-09-09 22:12:01.228946
+(add 4 5)

# 2021-09-09 22:12:22.632956
+(copyright
+)
+
+

# 2021-09-09 22:12:44.061471
+(copyright
+)
+
+(+ 4 5)

# 2021-09-09 22:12:52.969147
+(+ 4 5)

# 2021-09-09 22:13:05.588940
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:13:09.537018
+(+ 4 5)

# 2021-09-09 22:13:28.683435
+(copyright
+)
+
+(add 4 5)

# 2021-09-09 22:13:48.376031
+(add 4 5)

# 2021-09-09 22:14:17.480418
+(add 4 5
+)
+(add 41 11)

# 2021-09-09 22:14:58.072401
+(hash
+)
+

# 2021-09-09 22:15:06.313004
+(hash 54354)
+
+

# 2021-09-09 22:15:49.648383
+(range 1 99)

# 2021-09-09 22:16:16.520761
+4

# 2021-09-09 22:16:22.682437
+(add 4 7)

# 2021-09-09 22:18:26.287556
+(define x y)

# 2021-09-09 22:18:55.450472
+hissp.basic.._macro_.

# 2021-09-09 22:19:25.251011
+hissp.basic.._macro_

# 2021-09-09 22:19:36.022527
+_macro_

# 2021-09-09 22:20:03.378930
+(hissp.basic.._macro_.)

# 2021-09-09 22:21:23.288910
+hissp.basic.._macro_

# 2021-09-09 22:21:26.579723
+(define x y)

# 2021-09-09 22:21:43.092573
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:22:19.935396
+_macro_

# 2021-09-09 22:22:37.767149
+(let x 5)

# 2021-09-09 22:29:45.130374
+_macro_

# 2021-09-09 22:29:47.681635
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:29:56.576354
+hissp.basic.._macro_.prelude

# 2021-09-09 22:30:19.374852
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:31:36.532181
+_macro_

# 2021-09-09 22:32:35.409983
+(let x 5)

# 2021-09-09 22:32:40.336458
+let

# 2021-09-09 22:33:12.306399
+(let.__str__)

# 2021-09-09 22:34:58.993761
+lissp

# 2021-09-09 22:40:27.412948
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:40:55.470379
+ncgbnvb

# 2021-09-09 22:43:38.198680
+'ncgbnvb

# 2021-09-09 22:44:18.629677
+ncgbnvb

# 2021-09-09 22:44:28.444571
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:44:46.019589
+(let.__str__)

# 2021-09-09 22:44:57.821525
+(let x 5)

# 2021-09-09 22:45:31.068747
+(let.__str__)

# 2021-09-09 22:45:33.796327
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:45:37.503577
+(let x 5)

# 2021-09-09 22:46:11.451938
+(add 4 7)

# 2021-09-09 22:46:28.567443
+_macro_

# 2021-09-09 22:46:53.207005
+(let x 5)

# 2021-09-09 22:48:57.314706
+(add 4 7)

# 2021-09-09 22:49:08.816867
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:49:40.808482
+(add 4 7)

# 2021-09-09 22:49:42.653809
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:49:45.391919
+(add 4 7)

# 2021-09-09 22:49:51.274071
+(let x 5)

# 2021-09-09 22:50:14.754669
+(defmacro alias (alias module))

# 2021-09-09 22:50:32.305730
+(define L lambda)

# 2021-09-09 22:51:31.186877
+(define * mul)

# 2021-09-09 22:55:57.361267
+(let x 5)

# 2021-09-09 22:56:01.218584
+(hissp.basic.._macro_.prelude)

# 2021-09-09 22:56:03.786187
+(let x 5)

# 2021-09-09 22:56:08.570262
+(define * mul)

# 2021-09-09 22:56:13.381845
+(add 4 7)

# 2021-09-09 22:57:56.540055
+hissp.basic._macro_

# 2021-09-09 22:58:08.568905
+(vars hissp.basic._macro_)

# 2021-09-09 22:58:52.240253
+_macro_

# 2021-09-09 22:58:59.389541
+progn

# 2021-09-09 23:05:38.679540
+_macro_

# 2021-09-09 23:05:42.070289
+(vars hissp.basic._macro_)

# 2021-09-09 23:05:51.913301
+(define * mul)

# 2021-09-09 23:05:57.231162
+(hissp.basic.._macro_.prelude)

# 2021-09-09 23:05:59.178074
+(define * mul)

# 2021-09-09 23:06:05.930263
+progn

# 2021-09-09 23:06:11.333184
+(add 4 7)

# 2021-09-09 23:06:57.394622
+hissp.basic._macro_

# 2021-09-09 23:08:55.370439
+:foo->bar?

# 2021-09-09 23:09:06.468008
+operator.

# 2021-09-09 23:09:23.368586
+(lambda (: a 1  :/ :?  :* :?  b :?  c 2))

# 2021-09-09 23:09:55.728849
+(print 1 2 3 : sep ":"  end #"\n.")

# 2021-09-09 23:10:23.976462
+(print 1 _#"I'm not here!" 3) _#(I'm not here either.)

# 2021-09-09 23:10:40.100872
+`(1 2 ,(operator..add 1 2))

# 2021-09-09 23:10:49.610809
+`(:a ,@"bcd" :e)

# 2021-09-09 23:11:06.462584
+(list `(,@(.upper "abc") ,@[1,2,3] ,(.title "zed")))

# 2021-09-09 23:11:31.369439
+(hissp.basic.._macro_.define spam :eggs)

# 2021-09-09 23:11:36.166500
+spam

# 2021-09-09 23:11:58.754308
+hissp.basic.._macro_.

# 2021-09-09 23:12:06.274494
+(hissp.basic.._macro_.)

# 2021-09-09 23:12:13.509757
+(hissp.basic.._macro_)

# 2021-09-09 23:12:19.468726
+hissp.basic.._macro_

# 2021-09-09 23:12:30.858841
+_macro_.define

# 2021-09-09 23:12:39.857512
+hissp.basic.._macro_.define

# 2021-09-09 23:12:46.343369
+hissp.basic.

# 2021-09-09 23:12:50.226734
+_macro_.define

# 2021-09-09 23:14:53.334010
+(hissp.basic.._macro_.define _macro_ hissp.basic.._macro_)

# 2021-09-09 23:14:56.596105
+_macro_.define

# 2021-09-09 23:15:07.082314
+spam

# 2021-09-09 23:15:11.459951
+(define * mul)

# 2021-09-09 23:15:46.318526
+(setattr _macro_ 'hello (lambda () '(print 'hello)))

# 2021-09-09 23:15:55.191244
+(hello)

# 2021-09-09 23:17:37.727245
+ns

# 2021-09-09 23:18:06.536405
+__name__

# 2021-09-09 23:18:23.880457
+__package__

# 2021-09-09 23:18:29.509594
+_macro_

# 2021-09-09 23:18:48.789663
+_macro_.let

# 2021-09-09 23:18:56.461135
+(_macro_.let xx 4)

# 2021-09-09 23:19:22.723191
+_macro_.

# 2021-09-09 23:20:25.251269
+(vars _macro_)

# 2021-09-09 23:21:02.218815
+(define * mul)
