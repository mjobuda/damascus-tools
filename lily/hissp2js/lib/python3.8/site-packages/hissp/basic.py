("Hissp's basic macros.\n"
 '\n'
 "The basic macros are just enough to test and demonstrate Hissp's macro\n"
 'system; they are not intended to be a standard library for general use,\n'
 'but may suffice for small projects.\n'
 '\n'
 'As a convenience, they are automatically made available unqualified in\n'
 'the Lissp REPL, but this does not apply to modules. (A Hissp module with\n'
 'better alternatives need not use the basic macros at all.) In modules,\n'
 'either use the fully-qualified names, or start with the `prelude` macro.\n'
 '\n'
 'You can abbreviate qualifiers with the `alias` macro:\n'
 '\n'
 '.. code-block:: Lissp\n'
 '\n'
 '  (hissp.basic.._macro_.alias b/ hissp.basic.._macro_.)\n'
 '  ;; Now the same as (hissp.basic.._macro_.define foo 2).\n'
 '  (b/#define foo 2)\n'
 '\n'
 'The basic macros are deliberately restricted in design.\n'
 '\n'
 'They have NO DEPENDENCIES in their expansions; they use only the\n'
 'standard library with no extra helper functions. This means that all\n'
 'helper code must be inlined, resulting in larger expansions than might\n'
 'otherwise be necessary. But because macros expand before runtime, the\n'
 'compiled code does not require Hissp to be installed to work.\n'
 '\n'
 'They also have no prerequisite initialization, beyond what is available\n'
 'in a standard Python module. For example, a ``_macro_`` namespace need\n'
 "not be available for ``defmacro``. It's smart enough to check for the\n"
 'presence of ``_macro_`` in its expansion context, and inline the\n'
 'initialization code when required.\n'
 '\n'
 'With the exception of ``prelude`` (which uses `exec`), they also eschew\n'
 'any expansions to Python code, relying only on the built-in special\n'
 'forms ``quote`` and ``lambda``, which makes their expansions compatible\n'
 'with advanced rewriting macros that process the Hissp expansions of\n'
 'other macros.\n'
 '\n'
 'To help keep macro definitions and expansions manageable in complexity,\n'
 'these basic macros lack some of the extra features their equivalents\n'
 'have in Python or in other Lisps.\n')

__import__('operator').setitem(
  globals(),
  '_macro_',
  __import__('types').ModuleType(
    '_macro_'))

setattr(
  _macro_,
  'defmacro',
  (lambda name,parameters,docstring,*body:
    (lambda * _: _)(
      (lambda * _: _)(
        'lambda',
        (lambda * _: _)(
          ':',
          '_GxAUTO1_',
          (lambda * _: _)(
            'lambda',
            parameters,
            *body)),
        (lambda * _: _)(
          'builtins..setattr',
          '_GxAUTO1_',
          (lambda * _: _)(
            'quote',
            '__doc__'),
          docstring),
        (lambda * _: _)(
          'builtins..setattr',
          '_GxAUTO1_',
          (lambda * _: _)(
            'quote',
            '__qualname__'),
          (lambda * _: _)(
            '.join',
            "('.')",
            (lambda * _: _)(
              'quote',
              (lambda * _: _)(
                '_macro_',
                name)))),
        (lambda * _: _)(
          'builtins..setattr',
          'hissp.basic.._macro_',
          (lambda * _: _)(
            'quote',
            name),
          '_GxAUTO1_')))))

# defmacro
(lambda _GxAUTO1_=(lambda test,then,otherwise:
  (lambda * _: _)(
    (lambda * _: _)(
      'lambda',
      (lambda * _: _)(
        'test',
        ':',
        ':*',
        'thenxH_else'),
      (lambda * _: _)(
        (lambda * _: _)(
          'operator..getitem',
          'thenxH_else',
          (lambda * _: _)(
            'operator..not_',
            'test')))),
    test,
    (lambda * _: _)(
      'lambda',
      ':',
      then),
    (lambda * _: _)(
      'lambda',
      ':',
      otherwise))):(
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__doc__',
    ('``if-else`` Basic ternary branching construct.\n'
     '\n'
     "  Like Python's conditional expressions, the 'else' clause is required.\n"
     '  ')),
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'ifxH_else',))),
  __import__('builtins').setattr(
    __import__('builtins').globals()['_macro_'],
    'ifxH_else',
    _GxAUTO1_))[-1])()

# defmacro
(lambda _GxAUTO1_=(lambda *body:
  (lambda * _: _)(
    (lambda * _: _)(
      'lambda',
      ':',
      *body))):(
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__doc__',
    ('Evaluates each body expression in sequence (for side effects),\n'
     '  resulting in the value of the last (or ``()`` if empty).\n'
     '  ')),
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'progn',))),
  __import__('builtins').setattr(
    __import__('builtins').globals()['_macro_'],
    'progn',
    _GxAUTO1_))[-1])()

# defmacro
(lambda _GxAUTO1_=(lambda condition,*body:
  (lambda * _: _)(
    'hissp.basic.._macro_.ifxH_else',
    condition,
    (lambda * _: _)(
      'hissp.basic.._macro_.progn',
      *body),
    ())):(
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__doc__',
    ('When the condition is true,\n'
     '  evaluates each expression in sequence for side effects,\n'
     '  resulting in the value of the last.\n'
     '  Otherwise, skips them and returns ``()``.\n'
     '  ')),
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'when',))),
  __import__('builtins').setattr(
    __import__('builtins').globals()['_macro_'],
    'when',
    _GxAUTO1_))[-1])()

# defmacro
(lambda _GxAUTO1_=(lambda condition,*body:
  (lambda * _: _)(
    'hissp.basic.._macro_.ifxH_else',
    condition,
    (),
    (lambda * _: _)(
      'hissp.basic.._macro_.progn',
      *body))):(
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__doc__',
    ('Unless the condition is true,\n'
     '  evaluates each expression in sequence for side effects,\n'
     '  resulting in the value of the last.\n'
     '  Otherwise, skips them and returns ``()``.\n'
     '  ')),
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'unless',))),
  __import__('builtins').setattr(
    __import__('builtins').globals()['_macro_'],
    'unless',
    _GxAUTO1_))[-1])()

# defmacro
(lambda _GxAUTO1_=(lambda pairs,*body:
  (lambda * _: _)(
    (lambda * _: _)(
      'lambda',
      (lambda * _: _)(
        ':',
        *pairs),
      *body))):(
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__doc__',
    ('Creates local variables. Pairs are implied. Locals are not in scope until '
     'the body.')),
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'let',))),
  __import__('builtins').setattr(
    __import__('builtins').globals()['_macro_'],
    'let',
    _GxAUTO1_))[-1])()

# defmacro
(lambda _GxAUTO1_=(lambda name,parameters,docstring=(),*body:
  # let
  (lambda xDOLR_fn='_fnxAUTO7_':
    # let
    (lambda fn=(lambda * _: _)(
      'lambda',
      parameters,
      docstring,
      *body),ns=# unless
    # hissp.basic.._macro_.ifxH_else
    (lambda test,*thenxH_else:
      __import__('operator').getitem(
        thenxH_else,
        __import__('operator').not_(
          test))())(
      __import__('operator').contains(
        __import__('hissp.compiler',fromlist='?').NS.get(),
        '_macro_'),
      (lambda :()),
      (lambda :
        # hissp.basic.._macro_.progn
        (lambda :
          (lambda * _: _)(
            (lambda * _: _)(
              'operator..setitem',
              (lambda * _: _)(
                'builtins..globals'),
              (lambda * _: _)(
                'quote',
                '_macro_'),
              (lambda * _: _)(
                'types..ModuleType',
                (lambda * _: _)(
                  'quote',
                  '_macro_')))))())),dc=# when
    # hissp.basic.._macro_.ifxH_else
    (lambda test,*thenxH_else:
      __import__('operator').getitem(
        thenxH_else,
        __import__('operator').not_(
          test))())(
      __import__('hissp.reader',fromlist='?').is_string(
        docstring),
      (lambda :
        # hissp.basic.._macro_.progn
        (lambda :
          (lambda * _: _)(
            (lambda * _: _)(
              'builtins..setattr',
              xDOLR_fn,
              (lambda * _: _)(
                'quote',
                '__doc__'),
              docstring)))()),
      (lambda :())),qn=(lambda * _: _)(
      'builtins..setattr',
      xDOLR_fn,
      (lambda * _: _)(
        'quote',
        '__qualname__'),
      (lambda * _: _)(
        '.join',
        "('.')",
        (lambda * _: _)(
          'quote',
          (lambda * _: _)(
            '_macro_',
            name)))):
      (lambda * _: _)(
        'hissp.basic.._macro_.let',
        (lambda * _: _)(
          xDOLR_fn,
          fn),
        *ns,
        *dc,
        qn,
        (lambda * _: _)(
          'builtins..setattr',
          (lambda * _: _)(
            'operator..getitem',
            (lambda * _: _)(
              'builtins..globals'),
            (lambda * _: _)(
              'quote',
              '_macro_')),
          (lambda * _: _)(
            'quote',
            name),
          xDOLR_fn)))())()):(
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__doc__',
    ('Creates a new macro for the current module.\n'
     '\n'
     "  If there's no ``_macro_``, creates one (using `types.ModuleType`).\n"
     "  If there's a docstring, stores it as the new lambda's ``__doc__``.\n"
     "  Adds the ``_macro_`` prefix to the lambda's ``__qualname__``.\n"
     '  Saves the lambda in ``_macro_`` using the given attribute name.\n'
     '  ')),
  __import__('builtins').setattr(
    _GxAUTO1_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'defmacro',))),
  __import__('builtins').setattr(
    __import__('builtins').globals()['_macro_'],
    'defmacro',
    _GxAUTO1_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda name,value:(
  ('Assigns a global the value in the current module.'),
  (lambda * _: _)(
    'operator..setitem',
    (lambda * _: _)(
      'builtins..globals'),
    (lambda * _: _)(
      'quote',
      name),
    value))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Assigns a global the value in the current module.')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'define',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'define',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda name,bases,*body:(
  ('Defines a type (class) in the current module.\n'
   '\n'
   '  Key-value pairs are implied in the body.\n'
   '  '),
  (lambda * _: _)(
    'hissp.basic.._macro_.define',
    name,
    (lambda * _: _)(
      'builtins..type',
      (lambda * _: _)(
        'quote',
        name),
      (lambda * _: _)(
        __import__('hissp.reader',fromlist='?').ENTUPLE,
        *bases),
      (lambda * _: _)(
        'builtins..dict',
        ':',
        *body))))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Defines a type (class) in the current module.\n'
     '\n'
     '  Key-value pairs are implied in the body.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'deftype',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'deftype',
    _fnxAUTO7_))[-1])()

# define
__import__('operator').setitem(
  __import__('builtins').globals(),
  '_TAO',
  ('\n'
   'Nothingness above abstraction\n'
   '  but implementation is / the best name.\n'
   'Terseness may make one too many / get used to them\n'
   '  else overflow your brain.\n'
   'No substitute for understanding\n'
   'Code;     the liability\n'
   'as asset; the   ability.\n'
   'The biggest chunks / are hard to swallow\n'
   '  as simple as possible / no more.\n'
   'Source was made / for the human\n'
   '  object / the machine.\n'
   'Are you lazy enough to bear / the sincerest form / of other ways of being?\n'
   '*having* decent standards / is more important / than exactly what they are\n'
   'Perfection / is expensive\n'
   '  magic / highly priced\n'
   "  pay for when / it's Worth It\n"
   '  a quarter is advised\n'
   'Readability / is mainly / laid out on the page.\n'
   'Golfing / makes good practice / best practice it betrays.\n'
   'Castles built / in the air / whither they do belong?\n'
   '  Elegance / then exception\n'
   '  Form / before detail\n'
   '  whence under them,\n'
   'Foundations appear.\n'
   'Make the right way obvious,\n'
   'meditate on this.\n'
   '  --Za Zen of Hissp\n'))

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda *args:
  (lambda * _: _)(
    'builtins..print',
    'hissp.basic.._TAO')):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'import',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'import',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda target,*args:(
  ('Attaches the named variables to the target as attributes.\n'
   '\n'
   '  Positional arguments must be unqualified identifiers,\n'
   '  and use that as the attribute name.\n'
   '  Names after the ``:`` are identifier-value pairs.\n'
   '  Returns the target.\n'
   '  '),
  # let
  (lambda iargs=iter(
    args),xDOLR_target='_targetxAUTO16_':
    # let
    (lambda args=__import__('itertools').takewhile(
      (lambda a:
        __import__('operator').ne(
          a,
          ':')),
      iargs):
      (lambda * _: _)(
        'hissp.basic.._macro_.let',
        (lambda * _: _)(
          xDOLR_target,
          target),
        *map(
           (lambda arg:
             (lambda * _: _)(
               'builtins..setattr',
               xDOLR_target,
               (lambda * _: _)(
                 'quote',
                 arg),
               arg)),
           args),
        *map(
           (lambda kw:
             (lambda * _: _)(
               'builtins..setattr',
               xDOLR_target,
               (lambda * _: _)(
                 'quote',
                 kw),
               next(
                 iargs))),
           iargs),
        xDOLR_target))())())[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Attaches the named variables to the target as attributes.\n'
     '\n'
     '  Positional arguments must be unqualified identifiers,\n'
     '  and use that as the attribute name.\n'
     '  Names after the ``:`` are identifier-value pairs.\n'
     '  Returns the target.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'attach',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'attach',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda self,*invocations:(
  ("Call multiple 'methods' on one 'self'.\n"
   '\n'
   '  Evaluates the given ``self``, then injects it as the first argument to\n'
   '  a sequence of invocations. Returns the result of the last one.\n'
   '  '),
  # let
  (lambda xDOLR_self='_selfxAUTO20_':
    (lambda * _: _)(
      (lambda * _: _)(
        'lambda',
        (lambda * _: _)(
          ':',
          xDOLR_self,
          self),
        *map(
           (lambda invocation:
             (lambda * _: _)(
               __import__('operator').getitem(
                 invocation,
                 (0)),
               xDOLR_self,
               *__import__('operator').getitem(
                  invocation,
                  slice(
                    (1),
                    None)))),
           invocations))))())[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ("Call multiple 'methods' on one 'self'.\n"
     '\n'
     '  Evaluates the given ``self``, then injects it as the first argument to\n'
     '  a sequence of invocations. Returns the result of the last one.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'cascade',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'cascade',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda expr,*forms:(
  ("``->`` 'Thread-first'.\n"
   '\n'
   '  Converts a pipeline to function calls by recursively threading\n'
   '  expressions as the first argument of the next form.\n'
   '  E.g. ``(-> x (A b) (C d e))`` is ``(C (A x b) d e)``\n'
   '  Makes chained method calls easier to read.\n'
   '  '),
  # ifxH_else
  (lambda test,*thenxH_else:
    __import__('operator').getitem(
      thenxH_else,
      __import__('operator').not_(
        test))())(
    forms,
    (lambda :
      (lambda * _: _)(
        'hissp.basic..xAUTO_.xH_xGT_',
        (lambda * _: _)(
          __import__('operator').getitem(
            __import__('operator').getitem(
              forms,
              (0)),
            (0)),
          expr,
          *__import__('operator').getitem(
             __import__('operator').getitem(
               forms,
               (0)),
             slice(
               (1),
               None))),
        *__import__('operator').getitem(
           forms,
           slice(
             (1),
             None)))),
    (lambda :expr)))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ("``->`` 'Thread-first'.\n"
     '\n'
     '  Converts a pipeline to function calls by recursively threading\n'
     '  expressions as the first argument of the next form.\n'
     '  E.g. ``(-> x (A b) (C d e))`` is ``(C (A x b) d e)``\n'
     '  Makes chained method calls easier to read.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'xH_xGT_',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'xH_xGT_',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda expr,*forms:(
  ("``->>`` 'Thread-last'.\n"
   '\n'
   '  Converts a pipeline to function calls by recursively threading\n'
   '  expressions as the last argument of the next form.\n'
   '  E.g. ``(->> x (A b) (C d e))`` is ``(C d e (A b x))``.\n'
   '  Can replace partial application in some cases.\n'
   '  Also works inside a ``->`` pipeline.\n'
   '  E.g. ``(-> x (A a) (->> B b) (C c))`` is ``(C (B b (A x a)) c)``.\n'
   '  '),
  # ifxH_else
  (lambda test,*thenxH_else:
    __import__('operator').getitem(
      thenxH_else,
      __import__('operator').not_(
        test))())(
    forms,
    (lambda :
      (lambda * _: _)(
        'hissp.basic..xAUTO_.xH_xGT_xGT_',
        (lambda * _: _)(
          *__import__('operator').getitem(
             forms,
             (0)),
          expr),
        *__import__('operator').getitem(
           forms,
           slice(
             (1),
             None)))),
    (lambda :expr)))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ("``->>`` 'Thread-last'.\n"
     '\n'
     '  Converts a pipeline to function calls by recursively threading\n'
     '  expressions as the last argument of the next form.\n'
     '  E.g. ``(->> x (A b) (C d e))`` is ``(C d e (A b x))``.\n'
     '  Can replace partial application in some cases.\n'
     '  Also works inside a ``->`` pipeline.\n'
     '  E.g. ``(-> x (A a) (->> B b) (C c))`` is ``(C (B b (A x a)) c)``.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'xH_xGT_xGT_',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'xH_xGT_xGT_',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda *pairs:(
  ('Multiple condition branching.\n'
   '\n'
   '  Pairs are implied. Default is ``()``. Use ``:else`` to change it.\n'
   '  For example::\n'
   '\n'
   '   (cond)  ; ()\n'
   "   ;; Assume some number 'x\n"
   '   (cond (operator..gt x 0) (print "positive")\n'
   '         (operator..lt x 0) (print "negative")\n'
   '         (operator..eq x 0) (print "zero")\n'
   '         :else (print "not a number"))\n'
   '  '),
  # when
  # hissp.basic.._macro_.ifxH_else
  (lambda test,*thenxH_else:
    __import__('operator').getitem(
      thenxH_else,
      __import__('operator').not_(
        test))())(
    pairs,
    (lambda :
      # hissp.basic.._macro_.progn
      (lambda :
        (lambda * _: _)(
          'hissp.basic.._macro_.ifxH_else',
          __import__('operator').getitem(
            pairs,
            (0)),
          __import__('operator').getitem(
            pairs,
            (1)),
          (lambda * _: _)(
            'hissp.basic..xAUTO_.cond',
            *__import__('operator').getitem(
               pairs,
               slice(
                 (2),
                 None)))))()),
    (lambda :())))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Multiple condition branching.\n'
     '\n'
     '  Pairs are implied. Default is ``()``. Use ``:else`` to change it.\n'
     '  For example::\n'
     '\n'
     '   (cond)  ; ()\n'
     "   ;; Assume some number 'x\n"
     '   (cond (operator..gt x 0) (print "positive")\n'
     '         (operator..lt x 0) (print "negative")\n'
     '         (operator..eq x 0) (print "zero")\n'
     '         :else (print "not a number"))\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'cond',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'cond',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda variable,iterable,*body:(
  ('``any-for``\n'
   '  Bind the variable and evaluate the body for each item from the\n'
   '  iterable until any result is true (and return ``True``),\n'
   '  or until the iterable is exhausted (and return ``False``).\n'
   '  '),
  (lambda * _: _)(
    'builtins..any',
    (lambda * _: _)(
      'builtins..map',
      (lambda * _: _)(
        'lambda',
        (lambda * _: _)(
          variable),
        *body),
      iterable)))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('``any-for``\n'
     '  Bind the variable and evaluate the body for each item from the\n'
     '  iterable until any result is true (and return ``True``),\n'
     '  or until the iterable is exhausted (and return ``False``).\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'anyxH_for',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'anyxH_for',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda *exprs:(
  ("``&&`` 'and'. Shortcutting logical AND.\n"
   '  Returns the first false value, otherwise the last value.\n'
   '  There is an implicit initial value of ``True``.\n'
   '  '),
  # cond
  # hissp.basic.._macro_.ifxH_else
  (lambda test,*thenxH_else:
    __import__('operator').getitem(
      thenxH_else,
      __import__('operator').not_(
        test))())(
    __import__('operator').not_(
      exprs),
    (lambda :True),
    (lambda :
      # hissp.basic..xAUTO_.cond
      # hissp.basic.._macro_.ifxH_else
      (lambda test,*thenxH_else:
        __import__('operator').getitem(
          thenxH_else,
          __import__('operator').not_(
            test))())(
        __import__('operator').eq(
          len(
            exprs),
          (1)),
        (lambda :
          __import__('operator').getitem(
            exprs,
            (0))),
        (lambda :
          # hissp.basic..xAUTO_.cond
          # hissp.basic.._macro_.ifxH_else
          (lambda test,*thenxH_else:
            __import__('operator').getitem(
              thenxH_else,
              __import__('operator').not_(
                test))())(
            ':else',
            (lambda :
              (lambda * _: _)(
                'hissp.basic.._macro_.let',
                (lambda * _: _)(
                  '_GxAUTO27_',
                  __import__('operator').getitem(
                    exprs,
                    (0))),
                (lambda * _: _)(
                  'hissp.basic.._macro_.ifxH_else',
                  '_GxAUTO27_',
                  (lambda * _: _)(
                    'hissp.basic..xAUTO_.xET_xET_',
                    *__import__('operator').getitem(
                       exprs,
                       slice(
                         (1),
                         None))),
                  '_GxAUTO27_'))),
            (lambda :
              # hissp.basic..xAUTO_.cond
              ())))))))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ("``&&`` 'and'. Shortcutting logical AND.\n"
     '  Returns the first false value, otherwise the last value.\n'
     '  There is an implicit initial value of ``True``.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'xET_xET_',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'xET_xET_',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda first=(),*rest:(
  ("``||`` 'or'. Shortcutting logical OR.\n"
   '  Returns the first true value, otherwise the last value.\n'
   '  There is an implicit initial value of ``()``.\n'
   '  '),
  # ifxH_else
  (lambda test,*thenxH_else:
    __import__('operator').getitem(
      thenxH_else,
      __import__('operator').not_(
        test))())(
    rest,
    (lambda :
      (lambda * _: _)(
        'hissp.basic.._macro_.let',
        (lambda * _: _)(
          '_firstxAUTO28_',
          first),
        (lambda * _: _)(
          'hissp.basic.._macro_.ifxH_else',
          '_firstxAUTO28_',
          '_firstxAUTO28_',
          (lambda * _: _)(
            'hissp.basic..xAUTO_.xBAR_xBAR_',
            *rest)))),
    (lambda :first)))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ("``||`` 'or'. Shortcutting logical OR.\n"
     '  Returns the first true value, otherwise the last value.\n'
     '  There is an implicit initial value of ``()``.\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'xBAR_xBAR_',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'xBAR_xBAR_',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda expr1,*body:(
  ('Evaluates each expression in sequence (for side effects),\n'
   '  resulting in the value of the first.'),
  (lambda * _: _)(
    'hissp.basic.._macro_.let',
    (lambda * _: _)(
      '_value1xAUTO29_',
      expr1),
    *body,
    '_value1xAUTO29_'))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Evaluates each expression in sequence (for side effects),\n'
     '  resulting in the value of the first.')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'prog1',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'prog1',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda raw:(
  ('``b#`` bytes literal reader macro'),
  # xH_xGT_
  # hissp.basic..xAUTO_.xH_xGT_
  # hissp.basic..xAUTO_.xH_xGT_
  # hissp.basic..xAUTO_.xH_xGT_
  # hissp.basic..xAUTO_.xH_xGT_
  __import__('ast').literal_eval(
    # xH_xGT_xGT_
    # hissp.basic..xAUTO_.xH_xGT_xGT_
    ("b'{}'").format(
      raw.replace(
        ("'"),
        ("\\'")).replace(
        ('\n'),
        ('\\n')))))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('``b#`` bytes literal reader macro')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'bxHASH_',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'bxHASH_',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda :(
  ('Grants unqualified access to the basics.\n'
   '\n'
   '  Star imports from `operator` and `itertools`.\n'
   '  And adds the basic macros, but only if available,\n'
   '  so its expansion does not require Hissp to be installed.\n'
   '  (This replaces ``_macro_`` if you already had one.)\n'
   '  '),
  (lambda * _: _)(
    'builtins..exec',
    ("('from operator import *\\n'\n"
     " 'from itertools import *\\n'\n"
     " 'try:\\n'\n"
     " '    from hissp.basic import _macro_\\n'\n"
     ' "    _macro_ = __import__(\'types\').SimpleNamespace(**vars(_macro_))\\n"\n'
     " 'except ModuleNotFoundError:\\n'\n"
     " '    pass')")))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Grants unqualified access to the basics.\n'
     '\n'
     '  Star imports from `operator` and `itertools`.\n'
     '  And adds the basic macros, but only if available,\n'
     '  so its expansion does not require Hissp to be installed.\n'
     '  (This replaces ``_macro_`` if you already had one.)\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'prelude',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'prelude',
    _fnxAUTO7_))[-1])()

# defmacro
# hissp.basic.._macro_.let
(lambda _fnxAUTO7_=(lambda alias,module:(
  ('Defines a reader macro abbreviation of a symbol prefix\n'
   '  (such as a qualifier). For example,\n'
   '\n'
   '  .. code-block:: Lissp\n'
   '\n'
   '     (hissp.basic.._macro_.alias b/ hissp.basic.._macro_.)\n'
   '     ;; Now the same as (hissp.basic.._macro_.define foo 2).\n'
   '     (b/#define foo 2)\n'
   '  '),
  (lambda * _: _)(
    'hissp.basic.._macro_.defmacro',
    ('{}{}').format(
      alias,
      'xHASH_'),
    (lambda * _: _)(
      '_GxAUTO31_'),
    (lambda * _: _)(
      'quote',
      ('Aliases {} as {}#').format(
        module,
        alias)),
    (lambda * _: _)(
      '.format',
      "('{}{}')",
      (lambda * _: _)(
        'quote',
        module),
      '_GxAUTO31_')))[-1]):(
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__doc__',
    ('Defines a reader macro abbreviation of a symbol prefix\n'
     '  (such as a qualifier). For example,\n'
     '\n'
     '  .. code-block:: Lissp\n'
     '\n'
     '     (hissp.basic.._macro_.alias b/ hissp.basic.._macro_.)\n'
     '     ;; Now the same as (hissp.basic.._macro_.define foo 2).\n'
     '     (b/#define foo 2)\n'
     '  ')),
  __import__('builtins').setattr(
    _fnxAUTO7_,
    '__qualname__',
    ('.').join(
      ('_macro_',
       'alias',))),
  __import__('builtins').setattr(
    __import__('operator').getitem(
      __import__('builtins').globals(),
      '_macro_'),
    'alias',
    _fnxAUTO7_))[-1])()